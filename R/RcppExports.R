# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Box-muller
#'
#' Drawing univariate Gaussian random variables with mean mu in R and precision q > 0.
#' The function transforms a pair of independent uniform random variables into a pair
#' of Gaussian random variables by exploiting the radial symmetry of the
#' two-dimensional normal distribution.
#'
#' @param mu is mean of the distribution, one-dimensional.
#' @param q is precision of the distribution, one-dimensional.
#' @examples box_muller(0,1)
#' @export(box_muller)
box_muller <- function(mu, q) {
    .Call(`_GaussianSampling_C_box_muller`, mu, q)
}

#' Multivariate Gaussian sampling with diagonal precision matrix
#'
#' To generate a d-dimensional Gaussian vector theta with mean mu and diagonal precision matrix Q
#'
#' @param mu is mean, d-dimensional.
#' @param Q is diagonal precision matrix.
#' @examples GSdiag((rep(1,5),diag(2,5,5)))
#' @export(GSdiag)
GSdiag <- function(mu, Q) {
    .Call(`_GaussianSampling_C_GSdiag`, mu, Q)
}

#' Multivariate Gaussian sampling with sparse or band matrix Q
#'
#' To generate a d-dimensional Gaussian vector theta with mean mu and band precision matrix Q
#'
#' @param mu is mean, d-dimensional.
#' @param Q is band precision matrix.
#' @param b is bandwidth
#' @examples
#' Q <- diag(2,10,10); Q[4,1]<-Q[1,4]<-1;
#' GSband(rep(1,10),Q,3)
#' @export(GSband)
GSband <- function(mu, Q, b) {
    .Call(`_GaussianSampling_C_GSband`, mu, Q, b)
}

#' Multivariate Gaussian sampling with block circulant (Toeplitz) matrix Q
#'
#' Q is a block circulant matrix, then the sampling can be performed in the Fourier domain.
#'
#' @param mu is mean, d-dimensional.
#' @param a is vector built by stacking the first columns associated to the Q.
#' @param M is number of different blocks.
#' @param N is dimension of each block.
#' @examples
#' mu=rep(0,2); a=matrix(c(1,0),2,1); M=1; N=2;
#' GScirculant(mu, a, N, M)
#' @export(GScirculant)
GScirculant <- function(mu, a, N, M) {
    .Call(`_GaussianSampling_C_GScirc`, mu, a, N, M)
}

#' Cholesky Factorization Sampler
#'
#' Sampling based on the Cholesky decomposition on Q.
#'
#' @param mu is mean, d-dimensional.
#' @param Q is arbitrary precision matrix.
#' @examples
#' mu <- 1:10
#' Q <- diag(2,10,10); Q[4,1]<-Q[1,4]<-1;
#' GSchol(mu, Q)
#' @export(GSchol)
GSchol <- function(mu, Q) {
    .Call(`_GaussianSampling_C_GSchol`, mu, Q)
}

#' Square Root Factorization Sampler
#'
#' Useless
#'
#' @param mu is mean, d-dimensional.
#' @param Q is arbitrary precision matrix.
#' @examples
#' mu <- 1:10
#' Q <- diag(2,10,10); Q[4,1]<-Q[1,4]<-1;
#' GSsqrt(mu, Q)
#' @export(GSsqrt)
GSsqrt <- function(mu, Q) {
    .Call(`_GaussianSampling_C_GSsqrt`, mu, Q)
}

#' Chebyshev Polynomials Sampler
#'
#' Approx. square root sampler using Chebyshev polynomials
#'
#' @param mu is mean, d-dimensional.
#' @param Q is arbitrary precision matrix.
#' @param K is the order of the Chebyshev series.
#' @examples
#' mu <- 1:10
#' Q <- diag(2,10,10); Q[4,1]<-Q[1,4]<-1;
#' GScheby(mu, Q, 10)
#' @export(GScheby)
GScheby <- function(mu, Q, K) {
    .Call(`_GaussianSampling_C_GScheby`, mu, Q, K)
}

#' Lanczos Decomposition Sampler
#'
#' Approx. square root sampler using Lanczos decomposition
#'
#' @param mu is mean, d-dimensional.
#' @param Q is arbitrary precision matrix.
#' @param K is the dimension of Krylov subspace
#' @examples
#' mu <- 1:10
#' Q <- diag(2,10,10); Q[4,1]<-Q[1,4]<-1;
#' GSlanczos(mu, Q, 10)
#' @export(GSlanczos)
GSlanczos <- function(mu, Q, K) {
    .Call(`_GaussianSampling_C_GSlanczos`, mu, Q, K)
}

#' Conjugate Gradient Sampler
#'
#' Approx. square root sampler using Lanczos decomposition
#'
#' @param mu is mean, d-dimensional.
#' @param Q is arbitrary precision matrix.
#' @param epsilon is the tolerance threshold used to stop the conjugate gradient sampler.
#' @param omega0 is initialization.
#' @examples
#' mu <- 1:10
#' Q <- diag(2,10,10); Q[4,1]<-Q[1,4]<-1;
#' GSCG(mu,Q,1e-4,rep(0,10))
#' @export(GSCG)
GSCG <- function(mu, Q, epsilon, omega0) {
    .Call(`_GaussianSampling_C_GSCG`, mu, Q, epsilon, omega0)
}

#' Component-wise Gibbs sampler
#'
#' To sequentially draw one component of  given the others.
#'
#' @param mu is mean, d-dimensional.
#' @param Q is arbitrary precision matrix.
#' @param total_itr is the total itration of Gibbs sampler
#' @param theta0 is initialization.
#' @examples
#' mu <- 1:10
#' Q <- diag(2,10,10); Q[4,1]<-Q[1,4]<-1;
#' GSgibbs(mu,Q,1000,rep(0,10))
#' @export(GSgibbs)
GSgibbs <- function(mu, Q, total_itr, theta0) {
    .Call(`_GaussianSampling_C_GSgibbs`, mu, Q, total_itr, theta0)
}

#' MCMC sampler based on exact matrix splitting
#'
#' A perturbed instance of Matrix Splitting schemes which are a class of linear iterative solvers based on the splitting of Q into Q = M - N.
#'
#' @param mu is mean, d-dimensional.
#' @param Q is arbitrary precision matrix.
#' @param total_itr is the total itration of Gibbs sampler
#' @param theta0 is initialization.
#' @param method is matrix splitting approach to choose within "Gauss-Seidel", "Richardson", "Jacobi", "SOR".
#' @examples
#' mu <- 1:10
#' Q <- diag(2,10,10); Q[4,1]<-Q[1,4]<-1;
#' GSMS(mu,Q,100,rep(0,10), "SOR")
#' @export(GSMS)
GSMS <- function(mu, Q, total_itr, theta0, method) {
    .Call(`_GaussianSampling_C_GSMS`, mu, Q, total_itr, theta0, method)
}

#' Chebyshev accelerated SSOR sampler
#'
#' an accelerated version of exact matrix splitting sampler based on the SSOR splitting
#'
#' @param mu is mean, d-dimensional.
#' @param Q is arbitrary precision matrix.
#' @param total_itr is the total itration of Gibbs sampler
#' @param theta0 is initialization.
#' @examples
#' mu <- 1:10
#' Q <- diag(2,10,10); Q[4,1]<-Q[1,4]<-1;
#' GSMS_ssor(mu,Q,100,rep(0,10))
#' @export(GSMS_ssor)
GSMS_ssor <- function(mu, Q, total_itr, theta0) {
    .Call(`_GaussianSampling_C_GSMS_ssor`, mu, Q, total_itr, theta0)
}

#' MCMC sampler based on approximate matrix splitting
#'
#' MCMC samplers whose invariant distributions are approximations
#'
#' @param mu is mean, d-dimensional.
#' @param Q is arbitrary precision matrix.
#' @param total_itr is the total itration of Gibbs sampler
#' @param theta0 is initialization.
#' @param method is matrix splitting approach to choose within "Clone" and "Hogwild".
#' @examples
#' mu <- 1:10
#' Q <- diag(2,10,10); Q[4,1]<-Q[1,4]<-1;
#' GSAMS(mu,Q,500,rep(0,10),1, "Hogwild")
#' @export(GSAMS)
GSAMS <- function(mu, Q, total_itr, theta0, omega, method) {
    .Call(`_GaussianSampling_C_GSAMS`, mu, Q, total_itr, theta0, omega, method)
}

#' Gibbs sampler based on exact data augmentation
#'
#' MCMC samplers whose invariant distributions are approximations
#'
#' @param mu mu is mean, d-dimensional.
#' @param Q1 Q = Q1 + Q2.
#' @param G1 Q1 = G1T * Lambda1 * G1
#' @param Lambda1 Q1 = G1T * Lambda1 * G1
#' @param total_itr total_itr is the total itration of Gibbs sampler
#' @param theta0 theta0 is initialization.
#' @param method method is matrix splitting approach to choose within "EDA" and "GEDA".
#' @param omega omega is less than the inverse of spectral norm of Q1
#' @examples
#' mu <- 1:10
#' Q <- diag(2,10,10);
#' Q2 <- diag(1,10,10);
#' Q1 <- diag(1,10,10);
#' Lambda1 <- diag(eigen(Q1)$values)
#' G1 <- t(matrix(eigen(Q1)$vectors,10,10))
#' GSDA(mu,Q1,G1,Lambda1,10,rep(0,10),"GEDA", 1)
#' @export(GSDA)
GSDA <- function(mu, Q1, G1, Lambda1, total_itr, theta0, method, omega) {
    .Call(`_GaussianSampling_C_GSDA`, mu, Q1, G1, Lambda1, total_itr, theta0, method, omega)
}

